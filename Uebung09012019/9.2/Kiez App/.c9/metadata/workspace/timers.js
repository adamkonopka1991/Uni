{"changed":false,"filter":false,"title":"timers.js","tooltip":"timers.js","value":"'use strict';\n\nconst TimerWrap = process.binding('timer_wrap').Timer;\nconst L = require('internal/linkedlist');\nconst assert = require('assert');\nconst util = require('util');\nconst debug = util.debuglog('timer');\nconst kOnTimeout = TimerWrap.kOnTimeout | 0;\n\n// Timeout values > TIMEOUT_MAX are set to 1.\nconst TIMEOUT_MAX = 2147483647; // 2^31-1\n\n\n// HOW and WHY the timers implementation works the way it does.\n//\n// Timers are crucial to Node.js. Internally, any TCP I/O connection creates a\n// timer so that we can time out of connections. Additionally, many user\n// libraries and applications also use timers. As such there may be a\n// significantly large amount of timeouts scheduled at any given time.\n// Therefore, it is very important that the timers implementation is performant\n// and efficient.\n//\n// Note: It is suggested you first read though the lib/internal/linkedlist.js\n// linked list implementation, since timers depend on it extensively. It can be\n// somewhat counter-intuitive at first, as it is not actually a class. Instead,\n// it is a set of helpers that operate on an existing object.\n//\n// In order to be as performant as possible, the architecture and data\n// structures are designed so that they are optimized to handle the following\n// use cases as efficiently as possible:\n\n// - Adding a new timer. (insert)\n// - Removing an existing timer. (remove)\n// - Handling a timer timing out. (timeout)\n//\n// Whenever possible, the implementation tries to make the complexity of these\n// operations as close to constant-time as possible.\n// (So that performance is not impacted by the number of scheduled timers.)\n//\n// Object maps are kept which contain linked lists keyed by their duration in\n// milliseconds.\n// The linked lists within also have some meta-properties, one of which is a\n// TimerWrap C++ handle, which makes the call after the duration to process the\n// list it is attached to.\n//\n//\n// ╔════ > Object Map\n// ║\n// ╠══\n// ║ refedLists: { '40': { }, '320': { etc } } (keys of millisecond duration)\n// ╚══          ┌─────────┘\n//              │\n// ╔══          │\n// ║ TimersList { _idleNext: { }, _idlePrev: (self), _timer: (TimerWrap) }\n// ║         ┌────────────────┘\n// ║    ╔══  │                              ^\n// ║    ║    { _idleNext: { },  _idlePrev: { }, _onTimeout: (callback) }\n// ║    ║      ┌───────────┘\n// ║    ║      │                                  ^\n// ║    ║      { _idleNext: { etc },  _idlePrev: { }, _onTimeout: (callback) }\n// ╠══  ╠══\n// ║    ║\n// ║    ╚════ >  Actual JavaScript timeouts\n// ║\n// ╚════ > Linked List\n//\n//\n// With this, virtually constant-time insertion (append), removal, and timeout\n// is possible in the JavaScript layer. Any one list of timers is able to be\n// sorted by just appending to it because all timers within share the same\n// duration. Therefore, any timer added later will always have been scheduled to\n// timeout later, thus only needing to be appended.\n// Removal from an object-property linked list is also virtually constant-time\n// as can be seen in the lib/internal/linkedlist.js implementation.\n// Timeouts only need to process any timers due to currently timeout, which will\n// always be at the beginning of the list for reasons stated above. Any timers\n// after the first one encountered that does not yet need to timeout will also\n// always be due to timeout at a later time.\n//\n// Less-than constant time operations are thus contained in two places:\n// TimerWrap's backing libuv timers implementation (a performant heap-based\n// queue), and the object map lookup of a specific list by the duration of\n// timers within (or creation of a new list).\n// However, these operations combined have shown to be trivial in comparison to\n// other alternative timers architectures.\n\n\n// Object maps containing linked lists of timers, keyed and sorted by their\n// duration in milliseconds.\n//\n// The difference between these two objects is that the former contains timers\n// that will keep the process open if they are the only thing left, while the\n// latter will not.\n//\n// - key = time in milliseconds\n// - value = linked list\nconst refedLists = Object.create(null);\nconst unrefedLists = Object.create(null);\n\n\n// Schedule or re-schedule a timer.\n// The item must have been enroll()'d first.\nconst active = exports.active = function(item) {\n  insert(item, false);\n};\n\n// Internal APIs that need timeouts should use `_unrefActive()` instead of\n// `active()` so that they do not unnecessarily keep the process open.\nexports._unrefActive = function(item) {\n  insert(item, true);\n};\n\n\n// The underlying logic for scheduling or re-scheduling a timer.\n//\n// Appends a timer onto the end of an existing timers list, or creates a new\n// TimerWrap backed list if one does not already exist for the specified timeout\n// duration.\nfunction insert(item, unrefed) {\n  const msecs = item._idleTimeout;\n  if (msecs < 0 || msecs === undefined) return;\n\n  item._idleStart = TimerWrap.now();\n\n  const lists = unrefed === true ? unrefedLists : refedLists;\n\n  // Use an existing list if there is one, otherwise we need to make a new one.\n  var list = lists[msecs];\n  if (!list) {\n    debug('no %d list was found in insert, creating a new one', msecs);\n    lists[msecs] = list = createTimersList(msecs, unrefed);\n  }\n\n  L.append(list, item);\n  assert(!L.isEmpty(list)); // list is not empty\n}\n\nfunction createTimersList(msecs, unrefed) {\n  // Make a new linked list of timers, and create a TimerWrap to schedule\n  // processing for the list.\n  const list = new TimersList(msecs, unrefed);\n  L.init(list);\n  list._timer._list = list;\n\n  if (unrefed === true) list._timer.unref();\n  list._timer.start(msecs);\n\n  list._timer[kOnTimeout] = listOnTimeout;\n\n  return list;\n}\n\nfunction TimersList(msecs, unrefed) {\n  this._idleNext = null; // Create the list with the linkedlist properties to\n  this._idlePrev = null; // prevent any unnecessary hidden class changes.\n  this._timer = new TimerWrap();\n  this._unrefed = unrefed;\n  this.msecs = msecs;\n  this.nextTick = false;\n}\n\nfunction listOnTimeout() {\n  var list = this._list;\n  var msecs = list.msecs;\n\n  if (list.nextTick) {\n    list.nextTick = false;\n    process.nextTick(listOnTimeoutNT, list);\n    return;\n  }\n\n  debug('timeout callback %d', msecs);\n\n  var now = TimerWrap.now();\n  debug('now: %d', now);\n\n  var diff, timer;\n  while (timer = L.peek(list)) {\n    diff = now - timer._idleStart;\n\n    // Check if this loop iteration is too early for the next timer.\n    // This happens if there are more timers scheduled for later in the list.\n    if (diff < msecs) {\n      var timeRemaining = msecs - (TimerWrap.now() - timer._idleStart);\n      if (timeRemaining < 0) {\n        timeRemaining = 0;\n      }\n      this.start(timeRemaining);\n      debug('%d list wait because diff is %d', msecs, diff);\n      return;\n    }\n\n    // The actual logic for when a timeout happens.\n\n    L.remove(timer);\n    assert(timer !== L.peek(list));\n\n    if (!timer._onTimeout) continue;\n\n    var domain = timer.domain;\n    if (domain) {\n\n      // If the timer callback throws and the\n      // domain or uncaughtException handler ignore the exception,\n      // other timers that expire on this tick should still run.\n      //\n      // https://github.com/nodejs/node-v0.x-archive/issues/2631\n      if (domain._disposed)\n        continue;\n\n      domain.enter();\n    }\n\n    tryOnTimeout(timer, list);\n\n    if (domain)\n      domain.exit();\n  }\n\n  // If `L.peek(list)` returned nothing, the list was either empty or we have\n  // called all of the timer timeouts.\n  // As such, we can remove the list and clean up the TimerWrap C++ handle.\n  debug('%d list empty', msecs);\n  assert(L.isEmpty(list));\n\n  // Either refedLists[msecs] or unrefedLists[msecs] may have been removed and\n  // recreated since the reference to `list` was created. Make sure they're\n  // the same instance of the list before destroying.\n  if (list._unrefed === true && list === unrefedLists[msecs]) {\n    delete unrefedLists[msecs];\n  } else if (list === refedLists[msecs]) {\n    delete refedLists[msecs];\n  }\n\n  // Do not close the underlying handle if its ownership has changed\n  // (e.g it was unrefed in its callback).\n  if (this.owner)\n    return;\n\n  this.close();\n}\n\n\n// An optimization so that the try/finally only de-optimizes (since at least v8\n// 4.7) what is in this smaller function.\nfunction tryOnTimeout(timer, list) {\n  timer._called = true;\n  var threw = true;\n  try {\n    ontimeout(timer);\n    threw = false;\n  } finally {\n    if (!threw) return;\n\n    // Postpone all later list events to next tick. We need to do this\n    // so that the events are called in the order they were created.\n    const lists = list._unrefed === true ? unrefedLists : refedLists;\n    for (var key in lists) {\n      if (key > list.msecs) {\n        lists[key].nextTick = true;\n      }\n    }\n    // We need to continue processing after domain error handling\n    // is complete, but not by using whatever domain was left over\n    // when the timeout threw its exception.\n    const domain = process.domain;\n    process.domain = null;\n    // If we threw, we need to process the rest of the list in nextTick.\n    process.nextTick(listOnTimeoutNT, list);\n    process.domain = domain;\n  }\n}\n\n\nfunction listOnTimeoutNT(list) {\n  list._timer[kOnTimeout]();\n}\n\n\n// A convenience function for re-using TimerWrap handles more easily.\n//\n// This mostly exists to fix https://github.com/nodejs/node/issues/1264.\n// Handles in libuv take at least one `uv_run` to be registered as unreferenced.\n// Re-using an existing handle allows us to skip that, so that a second `uv_run`\n// will return no active handles, even when running `setTimeout(fn).unref()`.\nfunction reuse(item) {\n  L.remove(item);\n\n  var list = refedLists[item._idleTimeout];\n  // if empty - reuse the watcher\n  if (list && L.isEmpty(list)) {\n    debug('reuse hit');\n    list._timer.stop();\n    delete refedLists[item._idleTimeout];\n    return list._timer;\n  }\n\n  return null;\n}\n\n\n// Remove a timer. Cancels the timeout and resets the relevant timer properties.\nconst unenroll = exports.unenroll = function(item) {\n  var handle = reuse(item);\n  if (handle) {\n    debug('unenroll: list empty');\n    handle.close();\n  }\n  // if active is called later, then we want to make sure not to insert again\n  item._idleTimeout = -1;\n};\n\n\n// Make a regular object able to act as a timer by setting some properties.\n// This function does not start the timer, see `active()`.\n// Using existing objects as timers slightly reduces object overhead.\nexports.enroll = function(item, msecs) {\n  if (typeof msecs !== 'number') {\n    throw new TypeError('\"msecs\" argument must be a number');\n  }\n\n  if (msecs < 0 || !isFinite(msecs)) {\n    throw new RangeError('\"msecs\" argument must be ' +\n                         'a non-negative finite number');\n  }\n\n  // if this item was already in a list somewhere\n  // then we should unenroll it from that\n  if (item._idleNext) unenroll(item);\n\n  // Ensure that msecs fits into signed int32\n  if (msecs > TIMEOUT_MAX) {\n    msecs = TIMEOUT_MAX;\n  }\n\n  item._idleTimeout = msecs;\n  L.init(item);\n};\n\n\n/*\n * DOM-style timers\n */\n\n\nexports.setTimeout = function(callback, after, arg1, arg2, arg3) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  var len = arguments.length;\n  var args;\n  if (len === 3) {\n    args = [arg1];\n  } else if (len === 4) {\n    args = [arg1, arg2];\n  } else if (len > 4) {\n    args = [arg1, arg2, arg3];\n    for (var i = 5; i < len; i++)\n      // extend array dynamically, makes .apply run much faster in v6.0.0\n      args[i - 2] = arguments[i];\n  }\n\n  return createSingleTimeout(callback, after, args);\n};\n\nfunction createSingleTimeout(callback, after, args) {\n  after *= 1; // coalesce to number or NaN\n  if (!(after >= 1 && after <= TIMEOUT_MAX))\n    after = 1; // schedule on next tick, follows browser behaviour\n\n  var timer = new Timeout(after, callback, args);\n  if (process.domain)\n    timer.domain = process.domain;\n\n  active(timer);\n\n  return timer;\n}\n\n\nfunction ontimeout(timer) {\n  var args = timer._timerArgs;\n  var callback = timer._onTimeout;\n  if (!args)\n    callback.call(timer);\n  else {\n    switch (args.length) {\n      case 1:\n        callback.call(timer, args[0]);\n        break;\n      case 2:\n        callback.call(timer, args[0], args[1]);\n        break;\n      case 3:\n        callback.call(timer, args[0], args[1], args[2]);\n        break;\n      default:\n        callback.apply(timer, args);\n    }\n  }\n  if (timer._repeat)\n    rearm(timer);\n}\n\n\nfunction rearm(timer) {\n  // // Do not re-arm unenroll'd or closed timers.\n  if (timer._idleTimeout === -1) return;\n\n  // If timer is unref'd (or was - it's permanently removed from the list.)\n  if (timer._handle && timer instanceof Timeout) {\n    timer._handle.start(timer._repeat);\n  } else {\n    timer._idleTimeout = timer._repeat;\n    active(timer);\n  }\n}\n\n\nconst clearTimeout = exports.clearTimeout = function(timer) {\n  if (timer && (timer[kOnTimeout] || timer._onTimeout)) {\n    timer[kOnTimeout] = timer._onTimeout = null;\n    if (timer instanceof Timeout) {\n      timer.close(); // for after === 0\n    } else {\n      unenroll(timer);\n    }\n  }\n};\n\n\nexports.setInterval = function(callback, repeat, arg1, arg2, arg3) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  var len = arguments.length;\n  var args;\n  if (len === 3) {\n    args = [arg1];\n  } else if (len === 4) {\n    args = [arg1, arg2];\n  } else if (len > 4) {\n    args = [arg1, arg2, arg3];\n    for (var i = 5; i < len; i++)\n      // extend array dynamically, makes .apply run much faster in v6.0.0\n      args[i - 2] = arguments[i];\n  }\n\n  return createRepeatTimeout(callback, repeat, args);\n};\n\nfunction createRepeatTimeout(callback, repeat, args) {\n  repeat *= 1; // coalesce to number or NaN\n  if (!(repeat >= 1 && repeat <= TIMEOUT_MAX))\n    repeat = 1; // schedule on next tick, follows browser behaviour\n\n  var timer = new Timeout(repeat, callback, args);\n  timer._repeat = repeat;\n  if (process.domain)\n    timer.domain = process.domain;\n\n  active(timer);\n\n  return timer;\n}\n\nexports.clearInterval = function(timer) {\n  if (timer && timer._repeat) {\n    timer._repeat = null;\n    clearTimeout(timer);\n  }\n};\n\n\nfunction Timeout(after, callback, args) {\n  this._called = false;\n  this._idleTimeout = after;\n  this._idlePrev = this;\n  this._idleNext = this;\n  this._idleStart = null;\n  this._onTimeout = callback;\n  this._timerArgs = args;\n  this._repeat = null;\n}\n\n\nfunction unrefdHandle() {\n  // Don't attempt to call the callback if it is not a function.\n  if (typeof this.owner._onTimeout === 'function') {\n    ontimeout(this.owner);\n  }\n\n  // Make sure we clean up if the callback is no longer a function\n  // even if the timer is an interval.\n  if (!this.owner._repeat ||\n      typeof this.owner._onTimeout !== 'function') {\n    this.owner.close();\n  }\n}\n\n\nTimeout.prototype.unref = function() {\n  if (this._handle) {\n    this._handle.unref();\n  } else if (typeof this._onTimeout === 'function') {\n    var now = TimerWrap.now();\n    if (!this._idleStart) this._idleStart = now;\n    var delay = this._idleStart + this._idleTimeout - now;\n    if (delay < 0) delay = 0;\n\n    // Prevent running cb again when unref() is called during the same cb\n    if (this._called && !this._repeat) {\n      unenroll(this);\n      return;\n    }\n\n    var handle = reuse(this);\n\n    this._handle = handle || new TimerWrap();\n    this._handle.owner = this;\n    this._handle[kOnTimeout] = unrefdHandle;\n    this._handle.start(delay);\n    this._handle.domain = this.domain;\n    this._handle.unref();\n  }\n  return this;\n};\n\nTimeout.prototype.ref = function() {\n  if (this._handle)\n    this._handle.ref();\n  return this;\n};\n\nTimeout.prototype.close = function() {\n  this._onTimeout = null;\n  if (this._handle) {\n    this._idleTimeout = -1;\n    this._handle[kOnTimeout] = null;\n    this._handle.close();\n  } else {\n    unenroll(this);\n  }\n  return this;\n};\n\n\n// A linked list for storing `setImmediate()` requests\nfunction ImmediateList() {\n  this.head = null;\n  this.tail = null;\n}\n\n// Appends an item to the end of the linked list, adjusting the current tail's\n// previous and next pointers where applicable\nImmediateList.prototype.append = function(item) {\n  if (this.tail) {\n    this.tail._idleNext = item;\n    item._idlePrev = this.tail;\n  } else {\n    this.head = item;\n  }\n  this.tail = item;\n};\n\n// Removes an item from the linked list, adjusting the pointers of adjacent\n// items and the linked list's head or tail pointers as necessary\nImmediateList.prototype.remove = function(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n\n  if (item === this.head)\n    this.head = item._idleNext;\n  if (item === this.tail)\n    this.tail = item._idlePrev;\n\n  item._idleNext = null;\n  item._idlePrev = null;\n};\n\n// Create a single linked list instance only once at startup\nvar immediateQueue = new ImmediateList();\n\n\nfunction processImmediate() {\n  var immediate = immediateQueue.head;\n  var tail = immediateQueue.tail;\n  var domain;\n\n  // Clear the linked list early in case new `setImmediate()` calls occur while\n  // immediate callbacks are executed\n  immediateQueue.head = immediateQueue.tail = null;\n\n  while (immediate) {\n    domain = immediate.domain;\n\n    if (!immediate._onImmediate) {\n      immediate = immediate._idleNext;\n      continue;\n    }\n\n    if (domain)\n      domain.enter();\n\n    immediate._callback = immediate._onImmediate;\n\n    // Save next in case `clearImmediate(immediate)` is called from callback\n    var next = immediate._idleNext;\n\n    tryOnImmediate(immediate, tail);\n\n    if (domain)\n      domain.exit();\n\n    // If `clearImmediate(immediate)` wasn't called from the callback, use the\n    // `immediate`'s next item\n    if (immediate._idleNext)\n      immediate = immediate._idleNext;\n    else\n      immediate = next;\n  }\n\n  // Only round-trip to C++ land if we have to. Calling clearImmediate() on an\n  // immediate that's in |queue| is okay. Worst case is we make a superfluous\n  // call to NeedImmediateCallbackSetter().\n  if (!immediateQueue.head) {\n    process._needImmediateCallback = false;\n  }\n}\n\n\n// An optimization so that the try/finally only de-optimizes (since at least v8\n// 4.7) what is in this smaller function.\nfunction tryOnImmediate(immediate, oldTail) {\n  var threw = true;\n  try {\n    // make the actual call outside the try/catch to allow it to be optimized\n    runCallback(immediate);\n    threw = false;\n  } finally {\n    if (threw && immediate._idleNext) {\n      // Handle any remaining on next tick, assuming we're still alive to do so.\n      const curHead = immediateQueue.head;\n      const next = immediate._idleNext;\n      if (curHead) {\n        curHead._idlePrev = oldTail;\n        oldTail._idleNext = curHead;\n        next._idlePrev = null;\n        immediateQueue.head = next;\n      } else {\n        immediateQueue.head = next;\n        immediateQueue.tail = oldTail;\n      }\n      process.nextTick(processImmediate);\n    }\n  }\n}\n\nfunction runCallback(timer) {\n  const argv = timer._argv;\n  const argc = argv ? argv.length : 0;\n  switch (argc) {\n    // fast-path callbacks with 0-3 arguments\n    case 0:\n      return timer._callback();\n    case 1:\n      return timer._callback(argv[0]);\n    case 2:\n      return timer._callback(argv[0], argv[1]);\n    case 3:\n      return timer._callback(argv[0], argv[1], argv[2]);\n    // more than 3 arguments run slower with .apply\n    default:\n      return timer._callback.apply(timer, argv);\n  }\n}\n\n\nfunction Immediate() {\n  // assigning the callback here can cause optimize/deoptimize thrashing\n  // so have caller annotate the object (node v6.0.0, v8 5.0.71.35)\n  this._idleNext = null;\n  this._idlePrev = null;\n  this._callback = null;\n  this._argv = null;\n  this._onImmediate = null;\n  this.domain = process.domain;\n}\n\nexports.setImmediate = function(callback, arg1, arg2, arg3) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  var i, args;\n\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n      break;\n    case 2:\n      args = [arg1];\n      break;\n    case 3:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 4; i < arguments.length; i++)\n        // extend array dynamically, makes .apply run much faster in v6.0.0\n        args[i - 1] = arguments[i];\n      break;\n  }\n  return createImmediate(args, callback);\n};\n\nfunction createImmediate(args, callback) {\n  // declaring it `const immediate` causes v6.0.0 to deoptimize this function\n  var immediate = new Immediate();\n  immediate._callback = callback;\n  immediate._argv = args;\n  immediate._onImmediate = callback;\n\n  if (!process._needImmediateCallback) {\n    process._needImmediateCallback = true;\n    process._immediateCallback = processImmediate;\n  }\n\n  immediateQueue.append(immediate);\n\n  return immediate;\n}\n\n\nexports.clearImmediate = function(immediate) {\n  if (!immediate) return;\n\n  immediate._onImmediate = null;\n\n  immediateQueue.remove(immediate);\n\n  if (!immediateQueue.head) {\n    process._needImmediateCallback = false;\n  }\n};\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"customSyntax":"javascript","scrolltop":3008,"scrollleft":0,"selection":{"start":{"row":215,"column":4},"end":{"row":215,"column":4},"isBackwards":true},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":213,"state":"start","mode":"ace/mode/javascript"}}}